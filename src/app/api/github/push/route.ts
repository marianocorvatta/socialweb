import { NextRequest, NextResponse } from "next/server";
import { Octokit } from "@octokit/rest";
import { Vercel } from "@vercel/sdk";

interface PushRequest {
  branchName: string;
  htmlContent?: string;
  instagramUsername?: string;
  templateCode?: string;
}

const REPO_OWNER = "marianocorvatta";
const REPO_NAME = "socialweb-projects";

export async function POST(request: NextRequest) {
  try {
    const body = (await request.json()) as PushRequest;
    const { branchName, htmlContent, instagramUsername, templateCode } = body;

    if (!branchName) {
      return NextResponse.json(
        { error: "branchName is required" },
        { status: 400 }
      );
    }

    // Validate branch name (no spaces, special chars)
    if (!/^[a-zA-Z0-9_-]+$/.test(branchName)) {
      return NextResponse.json(
        { error: "Invalid branch name. Use only letters, numbers, hyphens and underscores" },
        { status: 400 }
      );
    }

    const octokit = new Octokit({
      auth: process.env.GITHUB_TOKEN,
    });

    console.log(`üöÄ Starting GitHub push for branch: ${branchName}`);

    // Prepare file contents
    const htmlContentFinal = templateCode || htmlContent || getDefaultHtml();

    const packageJson = {
      name: `site-${branchName}`,
      version: "1.0.0",
      description: `Static website for ${instagramUsername || branchName}`,
      scripts: {
        build: "echo 'No build needed for static site'",
      },
      keywords: ["static", "html"],
      author: instagramUsername || "SocialWeb",
      license: "MIT",
    };

    const vercelConfig = {
      version: 2,
      buildCommand: "echo 'Static site - no build needed'",
      outputDirectory: ".",
      routes: [{ src: "/(.*)", dest: "/index.html" }],
    };

    // Create blobs for each file in parallel
    const [htmlBlob, packageBlob, vercelBlob] = await Promise.all([
      octokit.git.createBlob({
        owner: REPO_OWNER,
        repo: REPO_NAME,
        content: Buffer.from(htmlContentFinal).toString("base64"),
        encoding: "base64",
      }),
      octokit.git.createBlob({
        owner: REPO_OWNER,
        repo: REPO_NAME,
        content: Buffer.from(JSON.stringify(packageJson, null, 2)).toString("base64"),
        encoding: "base64",
      }),
      octokit.git.createBlob({
        owner: REPO_OWNER,
        repo: REPO_NAME,
        content: Buffer.from(JSON.stringify(vercelConfig, null, 2)).toString("base64"),
        encoding: "base64",
      }),
    ]);

    console.log(`üìÑ Created blobs for files`);

    // Create a new tree with the files (no base_tree = fresh tree with only these files)
    const { data: newTree } = await octokit.git.createTree({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      tree: [
        { path: "index.html", mode: "100644", type: "blob", sha: htmlBlob.data.sha },
        { path: "package.json", mode: "100644", type: "blob", sha: packageBlob.data.sha },
        { path: "vercel.json", mode: "100644", type: "blob", sha: vercelBlob.data.sha },
      ],
    });

    console.log(`üå≥ Created new tree: ${newTree.sha}`);

    // Check if branch exists to determine if we need parents
    let parentSha: string | null = null;
    try {
      const { data: branchData } = await octokit.repos.getBranch({
        owner: REPO_OWNER,
        repo: REPO_NAME,
        branch: branchName,
      });
      parentSha = branchData.commit.sha;
      console.log(`üìÇ Branch exists, will update (parent: ${parentSha})`);
    } catch {
      console.log(`üìÇ Branch does not exist, will create orphan commit`);
    }

    // Create commit (with or without parent)
    const commitMessage = `Website for ${instagramUsername || branchName}\n\nGenerated by SocialWeb`;

    const { data: newCommit } = await octokit.git.createCommit({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      message: commitMessage,
      tree: newTree.sha,
      parents: parentSha ? [parentSha] : [], // Empty array = orphan commit (no parent)
      author: {
        name: "SocialWeb",
        email: "bot@socialweb.app",
        date: new Date().toISOString(),
      },
    });

    console.log(`üíæ Created commit: ${newCommit.sha}`);

    // Create or update the branch reference
    if (parentSha) {
      // Branch exists, update it
      await octokit.git.updateRef({
        owner: REPO_OWNER,
        repo: REPO_NAME,
        ref: `heads/${branchName}`,
        sha: newCommit.sha,
        force: true,
      });
      console.log(`‚úÖ Updated branch ${branchName}`);
    } else {
      // Branch doesn't exist, create it
      await octokit.git.createRef({
        owner: REPO_OWNER,
        repo: REPO_NAME,
        ref: `refs/heads/${branchName}`,
        sha: newCommit.sha,
      });
      console.log(`‚úÖ Created branch ${branchName}`);
    }

    // Trigger Vercel deployment
    let deploymentResult = null;

    if (instagramUsername && process.env.VERCEL_API_TOKEN) {
      console.log(`üöÄ Starting Vercel deployment for branch: ${branchName}`);

      try {
        const vercel = new Vercel({
          bearerToken: process.env.VERCEL_API_TOKEN,
        });

        const createResponse = await vercel.deployments.createDeployment({
          requestBody: {
            name: "socialweb-projects",
            target: "production",
            gitSource: {
              type: "github",
              repo: REPO_NAME,
              ref: branchName,
              org: REPO_OWNER,
            },
            projectSettings: {
              framework: null,
              devCommand: null,
              installCommand: null,
              buildCommand: "echo 'Static site'",
              outputDirectory: ".",
              rootDirectory: null,
            },
          },
        });

        const deploymentId = createResponse.id;
        const deploymentURL = createResponse.url;

        console.log(`‚úÖ Deployment created: ${deploymentId}`);

        // Wait for deployment to complete
        let deploymentStatus = createResponse.status;
        let attempts = 0;
        const maxAttempts = 60;

        while (
          ["BUILDING", "INITIALIZING", "QUEUED"].includes(deploymentStatus || "") &&
          attempts < maxAttempts
        ) {
          await new Promise((r) => setTimeout(r, 5000));
          const statusResponse = await vercel.deployments.getDeployment({
            idOrUrl: deploymentId,
          });
          deploymentStatus = statusResponse.status;
          attempts++;
          console.log(`üìä Status (${attempts}): ${deploymentStatus}`);
        }

        if (deploymentStatus === "READY") {
          // Try to assign alias
          const aliasName = `${instagramUsername}.vercel.app`;
          try {
            const aliasResponse = await vercel.aliases.assignAlias({
              id: deploymentId,
              requestBody: { alias: aliasName, redirect: null },
            });
            deploymentResult = {
              success: true,
              deploymentId,
              deploymentURL,
              alias: aliasResponse.alias,
            };
          } catch {
            deploymentResult = {
              success: true,
              deploymentId,
              deploymentURL,
              alias: null,
            };
          }
        } else {
          deploymentResult = {
            success: false,
            deploymentId,
            deploymentURL,
            error: `Status: ${deploymentStatus}`,
          };
        }
      } catch (deployError) {
        console.error("‚ùå Vercel error:", deployError);
        deploymentResult = {
          success: false,
          error: deployError instanceof Error ? deployError.message : "Unknown error",
        };
      }
    }

    return NextResponse.json({
      success: true,
      message: `Successfully pushed to branch: ${branchName}`,
      branch: branchName,
      repository: `https://github.com/${REPO_OWNER}/${REPO_NAME}`,
      commitSha: newCommit.sha,
      deployment: deploymentResult,
    });
  } catch (err) {
    console.error("Error pushing to GitHub:", err);
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    return NextResponse.json({ error: errorMessage, details: err }, { status: 500 });
  }
}

function getDefaultHtml(): string {
  return `<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mi Web</title>
</head>
<body>
    <h1>Hola Mundo</h1>
</body>
</html>`;
}
