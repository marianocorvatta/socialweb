import { NextRequest, NextResponse } from "next/server";
import { Octokit } from "@octokit/rest";
import { Vercel } from "@vercel/sdk";

interface PushRequest {
  branchName: string;
  htmlContent?: string;
  instagramUsername?: string;
  templateCode?: string;
  overwrite?: boolean;
}

const REPO_OWNER = "marianocorvatta";
const REPO_NAME = "socialweb-projects";

export async function POST(request: NextRequest) {
  try {
    const body = (await request.json()) as PushRequest;
    const {
      branchName,
      htmlContent,
      instagramUsername,
      templateCode,
    } = body;

    if (!branchName) {
      return NextResponse.json(
        { error: "branchName is required" },
        { status: 400 }
      );
    }

    // Validate branch name (no spaces, special chars)
    if (!/^[a-zA-Z0-9_-]+$/.test(branchName)) {
      return NextResponse.json(
        { error: "Invalid branch name. Use only letters, numbers, hyphens and underscores" },
        { status: 400 }
      );
    }

    // Initialize Octokit with GitHub token
    const octokit = new Octokit({
      auth: process.env.GITHUB_TOKEN,
    });

    console.log(`üöÄ Starting GitHub push for branch: ${branchName}`);

    // Get the default branch's latest commit SHA
    const { data: defaultBranch } = await octokit.repos.getBranch({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      branch: "main",
    });
    const baseSha = defaultBranch.commit.sha;
    console.log(`üìå Base commit SHA (main): ${baseSha}`);

    // Check if branch already exists
    let branchExists = false;
    try {
      await octokit.repos.getBranch({
        owner: REPO_OWNER,
        repo: REPO_NAME,
        branch: branchName,
      });
      branchExists = true;
      console.log(`üìÇ Branch ${branchName} already exists`);
    } catch {
      console.log(`üìÇ Branch ${branchName} does not exist, will create it`);
    }

    // Create the branch if it doesn't exist
    if (!branchExists) {
      await octokit.git.createRef({
        owner: REPO_OWNER,
        repo: REPO_NAME,
        ref: `refs/heads/${branchName}`,
        sha: baseSha,
      });
      console.log(`‚úÖ Created branch: ${branchName}`);
    }

    // Prepare file contents
    const htmlContentFinal = templateCode || htmlContent || getDefaultHtml();

    const packageJson = {
      name: `site-${branchName}`,
      version: "1.0.0",
      description: `Static website for ${instagramUsername || branchName}`,
      scripts: {
        build: "echo 'No build needed for static site'",
      },
      keywords: ["static", "html"],
      author: instagramUsername || "Warp Agent",
      license: "MIT",
    };

    const vercelConfig = {
      version: 2,
      buildCommand: "echo 'Static site - no build needed'",
      outputDirectory: ".",
      routes: [
        {
          src: "/(.*)",
          dest: "/index.html",
        },
      ],
    };

    // Get the current tree SHA for the branch
    const { data: branchData } = await octokit.repos.getBranch({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      branch: branchName,
    });
    const currentCommitSha = branchData.commit.sha;

    // Create blobs for each file
    const [htmlBlob, packageBlob, vercelBlob] = await Promise.all([
      octokit.git.createBlob({
        owner: REPO_OWNER,
        repo: REPO_NAME,
        content: Buffer.from(htmlContentFinal).toString("base64"),
        encoding: "base64",
      }),
      octokit.git.createBlob({
        owner: REPO_OWNER,
        repo: REPO_NAME,
        content: Buffer.from(JSON.stringify(packageJson, null, 2)).toString("base64"),
        encoding: "base64",
      }),
      octokit.git.createBlob({
        owner: REPO_OWNER,
        repo: REPO_NAME,
        content: Buffer.from(JSON.stringify(vercelConfig, null, 2)).toString("base64"),
        encoding: "base64",
      }),
    ]);

    console.log(`üìÑ Created blobs for files`);

    // Create a new tree with the files
    const { data: newTree } = await octokit.git.createTree({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      base_tree: currentCommitSha,
      tree: [
        {
          path: "index.html",
          mode: "100644",
          type: "blob",
          sha: htmlBlob.data.sha,
        },
        {
          path: "package.json",
          mode: "100644",
          type: "blob",
          sha: packageBlob.data.sha,
        },
        {
          path: "vercel.json",
          mode: "100644",
          type: "blob",
          sha: vercelBlob.data.sha,
        },
      ],
    });

    console.log(`üå≥ Created new tree: ${newTree.sha}`);

    // Create a new commit
    const commitMessage = templateCode
      ? `Add website generated by AI for ${branchName}\n\nTemplate code generated by AI assistant`
      : `Add index.html to ${branchName}`;

    const { data: newCommit } = await octokit.git.createCommit({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      message: commitMessage,
      tree: newTree.sha,
      parents: [currentCommitSha],
      author: {
        name: "Warp Agent",
        email: "agent@warp.dev",
        date: new Date().toISOString(),
      },
    });

    console.log(`üíæ Created commit: ${newCommit.sha}`);

    // Update the branch reference to point to the new commit
    await octokit.git.updateRef({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      ref: `heads/${branchName}`,
      sha: newCommit.sha,
      force: true,
    });

    console.log(`‚úÖ Updated branch ${branchName} to commit ${newCommit.sha}`);

    // Trigger Vercel deployment if instagramUsername is provided
    let deploymentResult = null;

    if (instagramUsername && process.env.VERCEL_TOKEN) {
      console.log(`üöÄ Starting Vercel deployment for branch: ${branchName}`);

      try {
        const vercel = new Vercel({
          bearerToken: process.env.VERCEL_TOKEN,
        });

        const projectName = "socialweb-projects";
        const aliasName = `${instagramUsername}.vercel.app`;

        const createResponse = await vercel.deployments.createDeployment({
          requestBody: {
            name: projectName,
            target: "production",
            gitSource: {
              type: "github",
              repo: REPO_NAME,
              ref: branchName,
              org: REPO_OWNER,
            },
            projectSettings: {
              framework: null,
              devCommand: null,
              installCommand: null,
              buildCommand: "echo 'Static site - no build needed'",
              outputDirectory: ".",
              rootDirectory: null,
            },
          },
        });

        const deploymentId = createResponse.id;
        const deploymentURL = createResponse.url;

        console.log(`‚úÖ Deployment created: ${deploymentId}, URL: ${deploymentURL}`);

        // Monitor deployment
        let deploymentStatus = createResponse.status;
        const maxAttempts = 60;
        let attempts = 0;

        while (
          (deploymentStatus === "BUILDING" ||
            deploymentStatus === "INITIALIZING" ||
            deploymentStatus === "QUEUED") &&
          attempts < maxAttempts
        ) {
          await new Promise((resolve) => setTimeout(resolve, 5000));

          const statusResponse = await vercel.deployments.getDeployment({
            idOrUrl: deploymentId,
            withGitRepoInfo: "true",
          });

          deploymentStatus = statusResponse.status;
          attempts++;

          console.log(`üìä Deployment status (${attempts}/${maxAttempts}): ${deploymentStatus}`);
        }

        if (deploymentStatus === "READY") {
          console.log(`üéâ Deployment successful!`);

          try {
            const aliasResponse = await vercel.aliases.assignAlias({
              id: deploymentId,
              requestBody: {
                alias: aliasName,
                redirect: null,
              },
            });

            console.log(`üîó Alias assigned: ${aliasResponse.alias}`);

            deploymentResult = {
              success: true,
              deploymentId,
              deploymentURL,
              status: deploymentStatus,
              alias: aliasResponse.alias,
              message: "Deployment completed and alias assigned successfully",
            };
          } catch (aliasError) {
            console.error(`‚ùå Error assigning alias:`, aliasError);
            deploymentResult = {
              success: true,
              deploymentId,
              deploymentURL,
              status: deploymentStatus,
              message: "Deployment completed but alias assignment failed",
              aliasError:
                aliasError instanceof Error
                  ? aliasError.message
                  : "Unknown alias error",
            };
          }
        } else if (attempts >= maxAttempts) {
          deploymentResult = {
            success: false,
            deploymentId,
            deploymentURL,
            status: deploymentStatus,
            error: "Deployment timeout",
          };
        } else {
          deploymentResult = {
            success: false,
            deploymentId,
            deploymentURL,
            status: deploymentStatus,
            error: `Deployment failed with status: ${deploymentStatus}`,
          };
        }
      } catch (deployError) {
        console.error("‚ùå Vercel deployment error:", deployError);
        deploymentResult = {
          initiated: false,
          error:
            deployError instanceof Error
              ? deployError.message
              : "Unknown deployment error",
        };
      }
    }

    return NextResponse.json({
      success: true,
      message: `Successfully pushed to branch: ${branchName}`,
      branch: branchName,
      repository: `https://github.com/${REPO_OWNER}/${REPO_NAME}`,
      file: "index.html",
      commitSha: newCommit.sha,
      timestamp: new Date().toISOString(),
      deployment: deploymentResult,
    });
  } catch (err) {
    console.error("Error pushing to GitHub:", err);
    const errorMessage = err instanceof Error ? err.message : "Unknown error";
    return NextResponse.json({ error: errorMessage, details: err }, { status: 500 });
  }
}

function getDefaultHtml(): string {
  return `<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hola Mundo</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .container {
            text-align: center;
            color: white;
            padding: 2rem;
        }
        h1 {
            font-size: 4rem;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        p {
            font-size: 1.5rem;
            margin-top: 1rem;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>¬°Hola Mundo!</h1>
        <p>Deployed from Next.js API</p>
    </div>
</body>
</html>`;
}
